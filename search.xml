<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Eigen使用MKL作为backend加速矩阵运算]]></title>
    <url>%2F2018%2Feigen-with-mkl%2F</url>
    <content type="text"><![CDATA[前言本文包含MKL配置、Cmake写法、Eigen中使用MKL的方法。 MKL安装下载地址：https://software.intel.com/en-us/mkl 解压后使用install_GUI.sh安装，默认安装路径为/opt/intel/mkl 可选配置项： 运行sudo gedit /etc/ld.so.conf.d/intel_mkl.conf，添加： 12/opt/intel/lib/intel64/opt/intel/mkl/lib/intel64 运行sudo ldconfig 运行sudo gedit /etc/profile，添加： 1export MKL_ROOT_DIR=/opt/intel/mkl 运行sudo source /etc/profile，尽量重启电脑以保证生效 Eigen+MKL的cmake写法工程目录结构1234/root ├── CMakeLists.txt ├── FindMKL.cmake └── main.cpp 工程CmakeList.txt写法其中启用OpenMP通过添加-fopenmp实现 12345678910111213141516cmake_minimum_required (VERSION 2.6 FATAL_ERROR)project(test)# 将根目录加入cmake module文件的搜索路径set(CMAKE_MODULE_PATH $&#123;CMAKE_MODULE_PATH&#125; "$&#123;CMAKE_SOURCE_DIR&#125;/")find_package(Eigen3)include_directories($&#123;EIGEN3_INCLUDE_DIR&#125;)find_package(MKL)include_directories($&#123;MKL_INCLUDE_DIR&#125;)include_directories($&#123;PROJECT_SOURCE_DIR&#125;)set( CMAKE_CXX_FLAGS "$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11 -fopenmp" )ADD_EXECUTABLE(exe main.cpp)TARGET_LINK_LIBRARIES(exe $&#123;MKL_LIBRARIES&#125;) FindMKL.cmake写法代码见文末，参考自链接，做了部分修改，其中set(MKL_LIBRARIES ${MKL_LP_SEQUENTIAL_LIBRARIES})一行最为关键。 MKL有以下概念： 数据格式，LP64和ILP64，其中LP64用于64位系统，ILP用于32位系统 线程类型，单线程SEQUENTIAL、GNU多线程GNUTHREAD、Intel多线程INTELTHREAD，Ubuntu下可使用GNU多线程，Win下可使用Intel多线程，对于较低维度的矩阵运算单线程似乎更快 MPI，分为NOMP、INTELMPI、OPENMPI、SGIMPT四种，本FindMKL.cmake暂未支持配置MPI Ubuntu下常用配置为 set(MKL_LIBRARIES ${MKL_LP_SEQUENTIAL_LIBRARIES})单线程 set(MKL_LIBRARIES ${MKL_LP_GNUTHREAD_LIBRARIES})多线程 示例代码Eigen123456789101112131415161718192021222324#define EIGEN_VECTORIZE_SSE4_2#include &lt;iostream&gt;#include &lt;time.h&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;int main()&#123; srand((unsigned)time(NULL)); clock_t start,finish; double totaltime; start=clock(); Eigen::MatrixXf m1 = Eigen::MatrixXf::Random(7000, 7000); Eigen::MatrixXf m2 = Eigen::MatrixXf::Random(7000, 7000); Eigen::MatrixXf m3 = m1*m2; finish=clock(); totaltime=(double)(finish-start)/CLOCKS_PER_SEC; std::cout&lt;&lt; "此程序的运行时间为" &lt;&lt; totaltime &lt;&lt; "秒" &lt;&lt;std::endl; return 0; Eigen+OpenMP添加-fopenmp编译参数，2线程，上一代码添加如下语句： 123456789101112#define EIGEN_VECTORIZE_SSE4_2#include &lt;iostream&gt;#include &lt;time.h&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;int main()&#123; omp_set_num_threads(2); ... Eigen+MKL单线程FindMKL.cmake中使用MKL_LP_SEQUENTIAL_LIBRARIES，添加#define EIGEN_USE_MKL_ALL 123456789101112#define EIGEN_USE_MKL_ALL#define EIGEN_VECTORIZE_SSE4_2#include &lt;iostream&gt;#include &lt;time.h&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;int main()&#123; ... Eigen+MKL多线程FindMKL.cmake中使用MKL_LP_GNUTHREAD_LIBRARIES，添加#define EIGEN_USE_MKL_ALL、omp_set_num_threads(2);，使用2线程 12345678910111213#define EIGEN_USE_MKL_ALL#define EIGEN_VECTORIZE_SSE4_2#include &lt;iostream&gt;#include &lt;time.h&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;int main()&#123; omp_set_num_threads(2); ... 结果对比由结果可见MKL可显著提升高阶矩阵的运算速度（另外测试发现低阶矩阵速度差别不大），在当前测试环境（i3+4g+Ubuntu15.04）下多线程并没有提升乘法的运算速度 测试项 线程 时间/秒 Eigen 1 27.1427 Eigen+OpenMP 2 31.3295 Eigen+MKL单线程 1 8.43301 Eigen+MKL多线程 2 9.5142 其他添加#define EIGEN_DONT_PARALLELIZE可使Eigen不适用任何并行加速，但对Eigen+MKL的配置方式无效，仅对Eigen或Eigen+OpenMP生效。 参考 http://eigen.tuxfamily.org/dox/TopicPreprocessorDirectives.html http://eigen.tuxfamily.org/dox/TopicUsingIntelMKL.html https://software.intel.com/en-us/mkl https://github.com/Eyescale/CMake/blob/master/FindMKL.cmake https://blog.csdn.net/LG1259156776/article/details/52730074?locationNum=6&amp;fps=1 附FindMKL.cmake 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207# - Try to find the Intel Math Kernel Library# Forked from: https://github.com/openmeeg/openmeeg/blob/master/macros/FindMKL.cmake# Once done this will define## MKL_FOUND - system has MKL# MKL_ROOT_DIR - path to the MKL base directory# MKL_INCLUDE_DIR - the MKL include directory# MKL_LIBRARIES - MKL libraries## There are few sets of libraries:# Array indexes modes:# LP - 32 bit indexes of arrays# ILP - 64 bit indexes of arrays# Threading:# SEQUENTIAL - no threading# INTEL - Intel threading library# GNU - GNU threading library# MPI support# NOMPI - no MPI support# INTEL - Intel MPI library# OPEN - Open MPI library# SGI - SGI MPT Library# linuxif(UNIX AND NOT APPLE) if($&#123;CMAKE_HOST_SYSTEM_PROCESSOR&#125; STREQUAL "x86_64") set(MKL_ARCH_DIR "intel64") else() set(MKL_ARCH_DIR "32") endif()endif()# macosif(APPLE) set(MKL_ARCH_DIR "em64t")endif()IF(FORCE_BUILD_32BITS) set(MKL_ARCH_DIR "32")ENDIF()if (WIN32) if($&#123;CMAKE_SIZEOF_VOID_P&#125; EQUAL 8) set(MKL_ARCH_DIR "intel64") else() set(MKL_ARCH_DIR "ia32") endif()endif()set (MKL_THREAD_VARIANTS SEQUENTIAL GNUTHREAD INTELTHREAD)set (MKL_MODE_VARIANTS ILP LP)set (MKL_MPI_VARIANTS NOMPI INTELMPI OPENMPI SGIMPT)find_path(MKL_ROOT_DIR include/mkl_cblas.h PATHS #$ENV&#123;MKL_ROOT_DIR&#125; /opt/intel/mkl/ /opt/intel/cmkl/ /Library/Frameworks/Intel_MKL.framework/Versions/Current/lib/universal "Program Files (x86)/Intel/ComposerXE-2011/mkl")MESSAGE("MKL_ROOT_DIR : $&#123;MKL_ROOT_DIR&#125;") # for debugfind_path(MKL_INCLUDE_DIR mkl_cblas.h PATHS $&#123;MKL_ROOT_DIR&#125;/include $&#123;INCLUDE_INSTALL_DIR&#125;)find_path(MKL_FFTW_INCLUDE_DIR fftw3.h PATH_SUFFIXES fftw PATHS $&#123;MKL_ROOT_DIR&#125;/include $&#123;INCLUDE_INSTALL_DIR&#125; NO_DEFAULT_PATH)find_library(MKL_CORE_LIBRARY mkl_core PATHS $&#123;MKL_ROOT_DIR&#125;/lib/$&#123;MKL_ARCH_DIR&#125; $&#123;MKL_ROOT_DIR&#125;/lib/)# Threading librariesfind_library(MKL_SEQUENTIAL_LIBRARY mkl_sequential PATHS $&#123;MKL_ROOT_DIR&#125;/lib/$&#123;MKL_ARCH_DIR&#125; $&#123;MKL_ROOT_DIR&#125;/lib/)find_library(MKL_INTELTHREAD_LIBRARY mkl_intel_thread PATHS $&#123;MKL_ROOT_DIR&#125;/lib/$&#123;MKL_ARCH_DIR&#125; $&#123;MKL_ROOT_DIR&#125;/lib/)find_library(MKL_GNUTHREAD_LIBRARY mkl_gnu_thread PATHS $&#123;MKL_ROOT_DIR&#125;/lib/$&#123;MKL_ARCH_DIR&#125; $&#123;MKL_ROOT_DIR&#125;/lib/)# Intel LibrariesIF("$&#123;MKL_ARCH_DIR&#125;" STREQUAL "32") find_library(MKL_LP_LIBRARY mkl_intel PATHS $&#123;MKL_ROOT_DIR&#125;/lib/$&#123;MKL_ARCH_DIR&#125; $&#123;MKL_ROOT_DIR&#125;/lib/ ) find_library(MKL_ILP_LIBRARY mkl_intel PATHS $&#123;MKL_ROOT_DIR&#125;/lib/$&#123;MKL_ARCH_DIR&#125; $&#123;MKL_ROOT_DIR&#125;/lib/ )else() find_library(MKL_LP_LIBRARY mkl_intel_lp64 PATHS $&#123;MKL_ROOT_DIR&#125;/lib/$&#123;MKL_ARCH_DIR&#125; $&#123;MKL_ROOT_DIR&#125;/lib/ ) find_library(MKL_ILP_LIBRARY mkl_intel_ilp64 PATHS $&#123;MKL_ROOT_DIR&#125;/lib/$&#123;MKL_ARCH_DIR&#125; $&#123;MKL_ROOT_DIR&#125;/lib/ )ENDIF()# Lapackfind_library(MKL_LAPACK_LIBRARY mkl_lapack PATHS $&#123;MKL_ROOT_DIR&#125;/lib/$&#123;MKL_ARCH_DIR&#125; $&#123;MKL_ROOT_DIR&#125;/lib/)IF(NOT MKL_LAPACK_LIBRARY) find_library(MKL_LAPACK_LIBRARY mkl_lapack95_lp64 PATHS $&#123;MKL_ROOT_DIR&#125;/lib/$&#123;MKL_ARCH_DIR&#125; $&#123;MKL_ROOT_DIR&#125;/lib/ )ENDIF()IF(NOT MKL_LAPACK_LIBRARY) SET(MKL_LAPACK_LIBRARY $&#123;MKL_ROOT_DIR&#125;/lib/$&#123;MKL_ARCH_DIR&#125;/lib/libmkl_lapack95_lp64.a)ENDIF()# iomp5IF("$&#123;MKL_ARCH_DIR&#125;" STREQUAL "32") IF(UNIX AND NOT APPLE) find_library(MKL_IOMP5_LIBRARY iomp5 PATHS $&#123;MKL_ROOT_DIR&#125;/../lib/intel64 ) ELSE() SET(MKL_IOMP5_LIBRARY "") # no need for mac ENDIF()else() IF(UNIX AND NOT APPLE) find_library(MKL_IOMP5_LIBRARY iomp5 PATHS $&#123;MKL_ROOT_DIR&#125;/../lib/intel64 ) ELSE() SET(MKL_IOMP5_LIBRARY "") # no need for mac ENDIF()ENDIF()foreach (MODEVAR $&#123;MKL_MODE_VARIANTS&#125;) foreach (THREADVAR $&#123;MKL_THREAD_VARIANTS&#125;) if (MKL_CORE_LIBRARY AND MKL_$&#123;MODEVAR&#125;_LIBRARY AND MKL_$&#123;THREADVAR&#125;_LIBRARY) set(MKL_$&#123;MODEVAR&#125;_$&#123;THREADVAR&#125;_LIBRARIES $&#123;MKL_$&#123;MODEVAR&#125;_LIBRARY&#125; $&#123;MKL_$&#123;THREADVAR&#125;_LIBRARY&#125; $&#123;MKL_CORE_LIBRARY&#125; $&#123;MKL_LAPACK_LIBRARY&#125; $&#123;MKL_IOMP5_LIBRARY&#125;) message("$&#123;MODEVAR&#125; $&#123;THREADVAR&#125; $&#123;MKL_$&#123;MODEVAR&#125;_$&#123;THREADVAR&#125;_LIBRARIES&#125;") # for debug endif() endforeach()endforeach()set(MKL_LIBRARIES $&#123;MKL_LP_SEQUENTIAL_LIBRARIES&#125;)LINK_DIRECTORIES($&#123;MKL_ROOT_DIR&#125;/lib/$&#123;MKL_ARCH_DIR&#125;) # hackinclude(FindPackageHandleStandardArgs)find_package_handle_standard_args(MKL DEFAULT_MSG MKL_INCLUDE_DIR MKL_LIBRARIES)mark_as_advanced(MKL_INCLUDE_DIR MKL_LIBRARIES MKL_CORE_LIBRARY MKL_LP_LIBRARY MKL_ILP_LIBRARY MKL_SEQUENTIAL_LIBRARY MKL_INTELTHREAD_LIBRARY MKL_GNUTHREAD_LIBRARY)]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>Eigen</tag>
        <tag>C++</tag>
        <tag>并行/并发/多线程</tag>
        <tag>MKL</tag>
        <tag>OpenMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eigen禁止Malloc动态内存分配的方法]]></title>
    <url>%2F2018%2Feigen-no-malloc%2F</url>
    <content type="text"><![CDATA[前言Eigen的基本数据类型分为Matrix和Array，其中Matrix用于线性代数运算，而Array用于更通用、可扩展的场景，在此仅讨论Matrix相关内容。本问主要讨论了Eigen中使用动态内存分配/堆分配的情况，以及避免或检测动态内存分配的方法。 Matrix的内存分配常用Eigen类型的内存分配 派生类型 Matrix类型 例 内存分配 Vector&lt;n&gt;&lt;type&gt;, 2≤n≤4 Matrix&lt;float/double/int,&lt;n&gt;,1&gt; Vector2f、Vector3d、Vector4i 静态 VectorX&lt;type&gt; Matrix&lt;float/double/int,Dynamic,1&gt; VectorXf(10)、VectorXd(100)、VectorXi(1000) 动态 RowVector&lt;n&gt;&lt;type&gt;, 2≤n≤4 Matrix&lt;float/double/int,1,&lt;n&gt;&gt; RowVector2f、RowVector3d、RowVector4i 静态 RowVectorX&lt;type&gt; Matrix&lt;float/double/int,1,Dynamic&gt; RowVectorXf(10)、RowVectorXd(100)、RowVectorXi(1000) 动态 Matrix&lt;n&gt;&lt;type&gt;, 2≤n≤4 Matrix&lt;float/double/int,&lt;n&gt;,&lt;n&gt;&gt; Matrix2f、Matrix3d、Matrix4i 静态 MatrixX&lt;type&gt; Matrix&lt;float/double/int,Dynamic,Dynamic&gt; MatrixXf(3,3)、MatrixXd(5,100)、Matrix4i(200,50) 动态 数据类型通用记法Eigen数据类型可通用的记成：&lt;矩阵类型&gt;&lt;维度&gt;&lt;数据类型&gt;的形式，具体的： &lt;矩阵类型&gt;可分为：Vector列向量、RowVector行向量、Matrix矩阵 &lt;维度&gt;对向量可分为：2、3、4、X，其中X为动态向量 &lt;维度&gt;对矩阵可分为：2、3、4、2X、3X、4X、X2、X3、X4、X，其中如2X代表2行任意列的动态矩阵，X代表行列均动态大小的矩阵 &lt;数据类型&gt;包含：f、d、i，分别对应float、double、int，以及cf、cd、ci，对应相应的复数形式 注：对于维度中所有包含X的类型均为动态类型，在变量定义时会使用动态内存分配 禁止动态内存分配的方法Eigen中的预编译宏Eigen中提供了两个宏来禁止内存分配： EIGEN_NO_MALLOC: if defined, any request from inside the Eigen to allocate memory from the heap results in an assertion failure. This is useful to check that some routine does not allocate memory dynamically. Not defined by default. EIGEN_RUNTIME_NO_MALLOC: if defined, a new switch is introduced which can be turned on and off by calling set_is_malloc_allowed(bool). If malloc is not allowed and Eigen tries to allocate memory dynamically anyway, an assertion failure results. Not defined by default. 简单的讲： EIGEN_NO_MALLOC: 禁止使用堆内存分配，如果使用将会触发断言 EIGEN_RUNTIME_NO_MALLOC: 提供一个接口set_is_malloc_allowed(bool)来细粒度控制禁止堆内存分配的代码段 注：两者不可混用 例子【重要】宏的声明必须在inclued之前，以保证正确启用 EIGEN_NO_MALLOC例： 1234567891011121314151617181920212223#define EIGEN_NO_MALLOC#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;int main()&#123; EEigen::Vector3f v1; //不会触发断言 Eigen::VectorXf v2; //不会触发断言 v2.resize(3); //会触发断言 Eigen::VectorXf v3(10); //会触发断言 Eigen::Matrix3f m1; //不会触发断言 Eigen::MatrixXf m2; //不会触发断言 m2.resize(5,5); //会触发断言 Eigen::MatrixXf m3(10,5); //会触发断言 //会触发断言 Eigen::MatrixXf m_svd = Eigen::MatrixXf::Random(6, 6); //会触发断言 Eigen::JacobiSVD&lt;Eigen::MatrixXf&gt; svd(m_svd, Eigen::ComputeFullV | Eigen::ComputeFullU); return 0;&#125; EIGEN_RUNTIME_NO_MALLOC例： 1234567891011121314#define EIGEN_RUNTIME_NO_MALLOC#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;int main()&#123; Eigen::internal::set_is_malloc_allowed(true); Eigen::VectorXf v1(10); //不会触发断言 Eigen::internal::set_is_malloc_allowed(false); Eigen::VectorXf v2(10); //会触发断言 return 0;&#125; 断言内容： 1/usr/include/eigen3/Eigen/src/Core/util/Memory.h:206: void Eigen::internal::check_that_malloc_is_allowed(): Assertion `is_malloc_allowed() &amp;&amp; &quot;heap allocation is forbidden (EIGEN_RUNTIME_NO_MALLOC is defined and g_is_malloc_allowed is false)&quot;&apos; failed. 避免动态内存分配的方法 对于2-4维的向量及矩阵可使用原生数据类型：Vector3f、Matrix4d等 避免使用带X的预制数据类型如：VectorXf、Matrix3Xd等 对于高维向量及矩阵可显式声明如：Matrix等价于10维Vector、Matrix等价于100行50列Matrix 编码中使用上述宏来检查是否使用动态内存分配 例： 1234567891011121314#define EIGEN_NO_MALLOC#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;int main()&#123; Eigen::Matrix&lt;float, 10, 1&gt; v1 //不会触发断言，等价于Eigen::VectorXf v1(10); Eigen::Matrix&lt;float, 10, 10&gt; m1 //不会触发断言，等价于Eigen::MatrixXf m1(10,10); Eigen::JacobiSVD&lt;Eigen::Matrix&lt;float, 10, 10&gt;&gt; svd(m1, Eigen::ComputeFullV | Eigen::ComputeFullU); //不会触发断言 return 0;&#125; 参考 http://eigen.tuxfamily.org/dox/TopicPreprocessorDirectives.html]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>Eigen</tag>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflexxes运动规划库简介]]></title>
    <url>%2F2018%2Freflexxes-motion-library-intro%2F</url>
    <content type="text"><![CDATA[概述Reflexxes（全称为Reflexxes Motion Library，简称RML）是一个开源（Type-II开源， Type-IV商业库）的在线运动轨迹生成库，具有众多优点使其可以应用于机器人、数控机床和伺服驱动系统等领域，V-REP中集成了RML-Type-IV,目前Reflexxes公司已经被谷歌收购。 Reflexxes算法库结构概述基本结构如下 Type-II和Type-IV相差加加速度的边界条件和加速度输出 Reflexxes的在线轨迹生成算法主要分为以下三步： Step 1: 计算同步时间 Step 2: 同步所选的轴 Step 3: 计算输出数值 由于仅有Type-II开源以下仅涉及Type-II相关内容 接口层 ReflexxesAPI是唯一的用户接口类非常紧凑，用它的两个方法ReflexxesAPI::RMLPosition来执行基于位置的在线轨迹生成算法和ReflexxesAPI::RMLVelocity用于基于速度的算法 RMLInputParameters：包含RMLPositionInputParameters和RMLVelocityInputParameters，用于输入参数 RMLOutputParameters：包含RMLPositionOutputParameters和RMLVelocityOutputParameters，用于输出参数 RMLFlags包含：RMLPositionFlags和RMLVelocityFlags，用于在线轨迹规划算法的参数化标记，如同步方式（无同步non-synchronized、时间同步time-synchronized、相位同步phase-synchronized）等 RMLVector：数组类 算法层包含实际的Type-II在线轨迹生成算法，提供给ReflexxesAPI使用，其中包含了数学层中提供的决策树TypeIIRMLDecisionTree TypeIIRMLPosition：ReflexxesAPI::RMLPosition，实际调用的是TypeIIRMLPosition::GetNextStateOfMotion TypeIIRMLVelocity：ReflexxesAPI::RMLVelocity，实际调用的是TypeIIRMLVelocity::GetNextStateOfMotion 数学层TypeIIRMLPosition和TypeIIRMLVelocity类所需的数学函数集合，包含： TypeIIRMLMath::MotionPolynomials：三个TypeIIRMLPolynomial数组（Pos、Vel、Acc） TypeIIRMLMath::TypeIIRMLPolynomial：三阶多项式 示例代码基本的三轴规划示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define CYCLE_TIME_IN_SECONDS 0.001#define NUMBER_OF_DOFS 3int main()&#123;// 变量声明 int ResultValue = 0 ; ReflexxesAPI *RML = NULL ; RMLPositionInputParameters *IP = NULL ; RMLPositionOutputParameters *OP = NULL ; RMLPositionFlags Flags ;// 初始化 RML = new ReflexxesAPI(NUMBER_OF_DOFS, CYCLE_TIME_IN_SECONDS); IP = new RMLPositionInputParameters(NUMBER_OF_DOFS); OP = new RMLPositionOutputParameters(NUMBER_OF_DOFS);// 输入参数 IP-&gt;CurrentPositionVector-&gt;VecData [0] = 100.0 ; IP-&gt;CurrentPositionVector-&gt;VecData [1] = 0.0 ; IP-&gt;CurrentPositionVector-&gt;VecData [2] = 50.0 ; IP-&gt;CurrentVelocityVector-&gt;VecData [0] = 100.0 ; IP-&gt;CurrentVelocityVector-&gt;VecData [1] = -220.0 ; IP-&gt;CurrentVelocityVector-&gt;VecData [2] = -50.0 ; IP-&gt;CurrentAccelerationVector-&gt;VecData [0] = -150.0 ; IP-&gt;CurrentAccelerationVector-&gt;VecData [1] = 250.0 ; IP-&gt;CurrentAccelerationVector-&gt;VecData [2] = -50.0 ; IP-&gt;MaxVelocityVector-&gt;VecData [0] = 300.0 ; IP-&gt;MaxVelocityVector-&gt;VecData [1] = 100.0 ; IP-&gt;MaxVelocityVector-&gt;VecData [2] = 300.0 ; IP-&gt;MaxAccelerationVector-&gt;VecData [0] = 300.0 ; IP-&gt;MaxAccelerationVector-&gt;VecData [1] = 200.0 ; IP-&gt;MaxAccelerationVector-&gt;VecData [2] = 100.0 ; IP-&gt;MaxJerkVector-&gt;VecData [0] = 400.0 ; IP-&gt;MaxJerkVector-&gt;VecData [1] = 300.0 ; IP-&gt;MaxJerkVector-&gt;VecData [2] = 200.0 ; IP-&gt;TargetPositionVector-&gt;VecData [0] = -600.0 ; IP-&gt;TargetPositionVector-&gt;VecData [1] = -200.0 ; IP-&gt;TargetPositionVector-&gt;VecData [2] = -350.0 ; IP-&gt;TargetVelocityVector-&gt;VecData [0] = 50.0 ; IP-&gt;TargetVelocityVector-&gt;VecData [1] = -50.0 ; IP-&gt;TargetVelocityVector-&gt;VecData [2] = -200.0 ; IP-&gt;SelectionVector-&gt;VecData [0] = true ; IP-&gt;SelectionVector-&gt;VecData [1] = true ; IP-&gt;SelectionVector-&gt;VecData [2] = true ;// 迭代运算 while (ResultValue != ReflexxesAPI::RML_FINAL_STATE_REACHED) &#123;// 获取下一周期状态 ResultValue = RML-&gt;RMLPosition(*IP, OP, Flags);// 更新当前状态 *IP-&gt;CurrentPositionVector = *OP-&gt;NewPositionVector ; *IP-&gt;CurrentVelocityVector = *OP-&gt;NewVelocityVector ; *IP-&gt;CurrentAccelerationVector = *OP-&gt;NewAccelerationVector ; &#125; delete RML ; delete IP ; delete OP ; exit(EXIT_SUCCESS) ;&#125; 参考 https://www.cnblogs.com/21207-iHome/p/6344467.html http://www.reflexxes.ws/software/typeiirml/v1.2.6/docs/index.html]]></content>
      <categories>
        <category>机器人</category>
      </categories>
      <tags>
        <tag>机器人</tag>
        <tag>Reflexxes</tag>
        <tag>运动规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KDL运动学动力学库类结构、接口整理]]></title>
    <url>%2F2018%2Fkdl-class-hierarchy%2F</url>
    <content type="text"><![CDATA[基本数据类型 Vector：double[3]，3维向量 Rotation：double[9]，3*3矩阵 Frame：Vector+Rotation，变换矩阵 Twist：Vector(平移速度)+Vector(旋转速度) Wrench：Vector(力)+Vector(转矩) Kinematic Trees运动学结构数据类型Joint关节Joint = JointType + Scale(输入输出比) + Offset(reference-&gt;joint)+非必要（Inertia惯量+Damping阻尼+Stiffness刚度）JointType = {RotAxis,RotX,RotY,RotZ,TransAxis,TransX,TransY,TransZ,None} RigidBodyInertia刚体惯量RigidBodyInertia = 质量+重力矩V3+转动惯量M3*3 Segment杆件Segment = Joint + RigidBodyInertia + Frame_reference + Frame_tip Chain无分支运动链Chain = Vector(Segment) 算法 基类 SolverI：solver interface用来存储和描述最近一次错误 正运动学 ChainFkSolverPos继承自SolverI：Chain的正运动学接口 ChainFkSolverPos_recursive继承自ChainFkSolverPos：递归fk ChainFkSolverVel_recursive继承自ChainFkSolverPos：递归fk-vel 例：ChainFkSolverPos_recursive接口 构造函数ChainFkSolverPos_recursive(const Chain&amp; chain) 接口virtual int JntToCart(const JntArray&amp; q_in, Frame&amp; p_out, int segmentNr=-1)、virtual int JntToCart(const JntArray&amp; q_in, std::vector&lt;Frame&gt;&amp; p_out, int segmentNr=-1); 逆运动学 ChainIkSolverPos继承自SolverI：Chain的逆运动学接口 ChainIkSolverPos_LMA继承自ChainIkSolverPos：逆运动学——莱文贝格-马夸特，Levenberg-Marquardt ChainIkSolverPos_NR：逆运动学——牛顿-拉夫森，Newton-Raphson ChainIkSolverPos_NR_JL：逆运动学——牛顿-拉夫森带关节限位，Newton-Raphson with joint limits ChainIkSolverVel_pinv继承自ChainIkSolverPos：ik-vel——广义伪逆，generalize pseudo inverse ChainIkSolverVel_pinv_nso：ik-vel——广义伪逆（冗余机器人优化） ChainIkSolverVel_pinv_givens：ik-vel——广义伪逆（Givens） ChainIkSolverVel_wdls：ik-vel——加权伪逆（阻尼最小二乘） 例：ChainIkSolverPos_LMA接口 构造函数 123456789101112ChainIkSolverPos_LMA( const KDL::Chain&amp; _chain, const Eigen::Matrix&lt;double,6,1&gt;&amp; _L, double _eps=1E-5, int _maxiter=500, double _eps_joints=1E-15); ChainIkSolverPos_LMA( const KDL::Chain&amp; _chain, double _eps=1E-5, int _maxiter=500, double _eps_joints=1E-15); 接口 1virtual int CartToJnt(const KDL::JntArray&amp; q_init, const KDL::Frame&amp; T_base_goal, KDL::JntArray&amp; q_out);]]></content>
      <categories>
        <category>机器人</category>
      </categories>
      <tags>
        <tag>KDL</tag>
        <tag>运动学</tag>
        <tag>ROS</tag>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KDL运动学动力学库简介]]></title>
    <url>%2F2018%2Fkdl-intro%2F</url>
    <content type="text"><![CDATA[前言仅整理了KDL里Chain运动学相关内容 基本数据类型 Vector：double[3]，3维向量 Rotation：double[9]，3*3矩阵 Frame：Vector+Rotation，变换矩阵 Twist：Vector(平移速度)+Vector(旋转速度) Wrench：Vector(力)+Vector(转矩) Vecto2r：double[2]，2维向量 Rotation2： $cos\theta$，$sin\theta$，旋转矩阵 Frame2：Vector2+Rotation2，变换矩阵 Kinematic Trees运动学结构数据类型 Tree：开链机构，树 Chain：无分支的运动链 Chain和Tree都由最基本的Segments元素串接而成，Segment可以理解为机构运动链上的一个运动部件。如下图所示Segment包含关节Joint以及部件的质量/惯性属性RigidBodyInertia，并且定义了一个参考坐标系Freference和末端坐标系Ftip。 末端到关节坐标系的转换由Ttip描述。在一个运动链或树中，子部件会被添加到父部件的末端，因此上一个部件的Ftip就是下一个部件的参考坐标系Freference (tip frame of parent = reference frame of the child)。通常Fjoint和Freference是重合的，但是也可以存在偏移。 运动学算法框架以下均为Chain相关运动学算法类 基类 SolverI：solver interface用来存储和描述最近一次错误 正运动学 ChainFkSolverPos继承自SolverI：Chain的正运动学接口 ChainFkSolverPos_recursive继承自ChainFkSolverPos：递归fk ChainFkSolverVel_recursive继承自ChainFkSolverPos：递归fk-vel 逆运动学 ChainIkSolverPos继承自SolverI：Chain的逆运动学接口 ChainIkSolverPos_LMA继承自ChainIkSolverPos：逆运动学——莱文贝格-马夸特，Levenberg-Marquardt ChainIkSolverPos_NR：逆运动学——牛顿-拉夫森，Newton-Raphson ChainIkSolverPos_NR_JL：逆运动学——牛顿-拉夫森带关节限位，Newton-Raphson with joint limits ChainIkSolverVel_pinv继承自ChainIkSolverPos：ik-vel——广义伪逆，generalize pseudo inverse ChainIkSolverVel_pinv_nso：ik-vel——广义伪逆（冗余机器人优化） ChainIkSolverVel_pinv_givens：ik-vel——广义伪逆（Givens） ChainIkSolverVel_wdls：ik-vel——加权伪逆（阻尼最小二乘） 参考 https://www.cnblogs.com/21207-iHome/p/8312854.html http://www.orocos.org/kdl]]></content>
      <categories>
        <category>机器人</category>
      </categories>
      <tags>
        <tag>KDL</tag>
        <tag>运动学</tag>
        <tag>ROS</tag>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数库调研]]></title>
    <url>%2F2018%2Flinear-algebra-library%2F</url>
    <content type="text"><![CDATA[前言本文罗列了线性代数库/API相关的内容，包含基本数学库/API和高级数学库相关内容，以及他们之间的对比，可跳过前面直接阅读“线性代数库选用”相关内容。 基本数学库/APIBLAS简介：基本线性代数子程序，Basic Linear Algebra Subprograms，是一个API标淮，用以规范发布基础线性代数操作的数值库（如矢量或矩阵乘法）。Netlib用Fortran实现了BLAS的这些API接口，得到的库也叫做BLAS。Netlib只是一般性地实现了基本功能，并没有对运算做过多的优化。在高性能计算领域，BLAS被广泛使用。为提高性能，各软硬件厂商则针对其产品对BLAS接口实现进行高度最佳化。 参考链接： http://www.netlib.org/blas/ https://zh.wikipedia.org/wiki/BLAS LAPACK简介：线性代数库，也是Netlib用fortran语言编写的，其底层是BLAS。LAPACK提供了丰富的工具函式，可用于诸如解多元线性方程式、线性系统方程组的最小平方解、计算特徵向量、用于计算矩阵QR分解的Householder转换、以及奇异值分解等问题。该库的运行效率比BLAS库高。从某个角度讲，LAPACK也可以称作是一组科学计算（矩阵运算）的接口规范。Netlib实现了这一组规范的功能，得到的这个库叫做LAPACK库。 参考链接 http://www.netlib.org/lapack/ https://zh.wikipedia.org/wiki/LAPACK ScaLAPACK简介：ScaLAPACK（Scalable LAPACK 简称）是一个并行计算软件包，适用于分布式存储的 MIMD （multiple instruction, multiple data）并行计算机。它是采用消息传递机制实现处理器/进程间通信，因此使用起来和编写传统的 MPI 程序比较类似。ScaLAPACK 主要针对密集和带状线性代数系统，提供若干线性代数求解功能，如各种矩阵运算，矩阵分解，线性方程组求解，最小二乘问题，本征值问题，奇异值问题等，具有高效、可移植、可伸缩、高可靠性等优点，利用它的求解库可以开发出基于线性代数运算的并行应用程序。 参考链接 http://www.netlib.org/scalapack/index.html https://blog.csdn.net/zuoshifan/article/details/80273198 高级数学库MKL简介：英特尔MKL基于英特尔® C++和Fortran编译器构建而成，并使用OpenMP*实现了线程化。该函数库的算法能够平均分配数据和任务，充分利用多个核心和处理器。支持Linux/Win。 底层： BLAS：所有矩阵间运算（三级）均面向密集和稀疏 BLAS 实现了线程化。 许多矢量间运算（一级）和矩阵与矢量的运算（二级）均面向英特尔® 64 架构上 64 位程序中的密集型矩阵实现了线程化。 对于稀疏矩阵，除三角形稀疏矩阵解算器外的所有二级运算均实现了线程化。 LAPACK：部分计算例程针对以下某类型的问题实现了线程化：线性方程解算器、正交因子分解、单值分解和对称特征值问题。 LAPACK 也调用 BLAS，因此即使是非线程化函数也可能并行运行。 ScaLAPACK：面向集群的 LAPACK 分布式内存并行版本。 PARDISO：该并行直接稀疏矩阵解算器的三个阶段均实现了线程化：重新排序（可选）、因子分解和解算（如果采用多个右侧项）。 DFTs：离散傅立叶变换 VML：矢量数学库 VSL：矢量统计学库 参考资料： https://software.intel.com/es-es/node/699485 http://www.docin.com/p-1907272173.html Armadillo简介：使用模板元编程技术，与Matlab相似，易于使用的C++矩阵库，提供高效的 LAPACK, BLAS和ATLAS封装包，包含了 Intel MKL, AMD ACM和 OpenBLAS等诸多高性能版本。 底层： BLAS/LAPACK：支持OpenBLAS、ACML、MKL 参考链接： http://arma.sourceforge.net/ https://en.wikipedia.org/wiki/Armadillo_(C%2B%2B_library) Eigen简介：Eigen是可以用来进行线性代数、矩阵、向量操作等运算的C++库，它里面包含了很多算法。它支持多平台。Eigen采用源码的方式提供给用户使用，在使用时只需要包含Eigen的头文件即可进行使用。之所以采用这种方式，是因为Eigen采用模板方式实现，由于模板函数不支持分离编译，所以只能提供源码而不是动态库的方式供用户使用。 底层： BLAS/LAPACK：支持所有基于F77的BLAS或LAPACK库作为底层（EIGEN_USE_BLAS、EIGEN_USE_LAPACKE） MKL：支持MKL作为底层（EIGEN_USE_MKL_ALL） CUDA：支持在CUDA kernels里使用CUDA OpenMP：多线程优化 参考链接 http://eigen.tuxfamily.org/index.php?title=Main_Page http://eigen.tuxfamily.org/dox/TopicUsingBlasLapack.html http://eigen.tuxfamily.org/dox/TopicUsingIntelMKL.html 线性代数库选用关系 狭义的BLAS/LAPACK可理解为用于线性代数运算库的API Netlib实现了Fortran/C版的BLAS/LAPACK、CBLAS/CLAPACK 开源社区及商业公司针对API实现了BLAS（ATLAS、OpenBLAS）和LAPACK（MKL、ACML、CUBLAS）的针对性优化 Eigen、Armadillo除自身实现线性代数运算库外还支持上述各种BLAS/LAPACK为基础的底层以加速运算 对比 备选：MKL、OpenBLAS、Eigen、Armadillo 接口易用程度：Eigen &gt; Armadillo &gt; MKL/OpenBLAS 速度：MKL≈OpenBLAS &gt; Eigen(with MKL) &gt; Eigen &gt; Armadillo 其中： OpenBLAS没有单核版本，强行指定OMP_NUM_THREADS=1性能损失大，不考虑 MKL直接使用学习成本较高，但是性能最强 Armadillo效率和接口易用性不如Eigen Eigen的原生BLAS/LAPACK实现速度不如MKL、OpenBLAS，但是使用MKL做后台性能和MKL原生几乎一样，所以可以视情况决定是否使用MKL 参考资料 blas、lapack和atlas、openblas的区别联系 比较OpenBLAS，Intel MKL和Eigen的矩阵相乘性能 Eigen、OpenCV、Armadillo对比 更多线性代数库的对比]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Eigen</tag>
        <tag>MKL</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++并发Hash库junction简介]]></title>
    <url>%2F2018%2Fconcurrent-hash-guide%2F</url>
    <content type="text"><![CDATA[写在最前面由于一个算法环节的优化中，需要通过Hash表的并发读写来优化速度，而std::map和std::unordered_map并非线程安全，如果一定要用只能加锁，但这样又会有额外消耗，得不偿失。因此需求一个线程安全的并发HashMap，现有的C++库选择并不多比如TBB，偶然间发现了Junction_ConcurrentMap库,本文对HashMap、现有C++并发Hash库、Junction的编译及用例做了简要介绍，并未涉及Hash函数相关内容。 什么是HashMap数组和链表数组和链表是两种常见的数据结构，他们各有优缺点： 数组长度固定，下标与值一一对应，可以通过下标对存储的值进行索引,查询时间复杂度为O(1)。其长度固定正是其缺点，分配长度过短如果实际存储数据量超过定长会报错，而分配过大空间又会造成不必要的浪费，且占据的空间不会随元素的删除而释放。 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，其优势为无长度限制，非顺序的存储结构使内存利用更为充分，一般的单链表查询时间复杂度为O(n)。 HashMapHashMap则是一种既不定长又无需遍历查询的数据结构，在无冲突的情况下时间复杂度为O(1)，而这是通过牺牲更大空间而实现的，是一种空间换时间的做法。HashMap用KEY-VALUE来实现数据存储，插入数据时将KEY通过Hash函数转换为Hashcode(通常为32位或64位uint)，由Hashcode决定存储的位置。但是存在一个冲突问题，那就是当你用Hash函数作用在两个互不相同KEY时，得到了相同的Hashcode，也就是不同的KEY-VALUE将会存到相同位置，这时就需要解决冲突，通常的解决办法有：开放定址法、链地址法、再哈希法等。 C++并发HashMapC++并没有像Java那样原生的ConcurrentHashMap，通常有如下解决方案： std::map+std::mutex：利用std::map加锁实现 TBB concurrent_hash_map：Intel公司开发的并行编程开发的工具 libCds MichaelKVList：一个无锁、细粒度算法的C++模板库 nbds hashtable_t：非阻塞结构的C实现 Tervel HashMap：一种为共享内存系统设计的无等待算法 Folly AtomicHashMap：一个Facebook开源的C++库 junction关于junctionjunction是一个并发数据结构库，也正是本文将着重介绍的。junction包含多种HashMap的实现方式： ConcurrentMap_Crude：一种并发HashMap的简陋实现 junction::ConcurrentMap_Linea：一种受Java non-blocking HashMap启发的简单无锁HashMap junction::ConcurrentMap_Leapfrog：类似于Linea，但是使用了跳房子哈希法（Hopscotch Hashing）的松散搜索策略 junction::ConcurrentMap_Grampa：其与Leapfrog类似，但是在数据量大的时候会拆分成多个更小的、定长的Leapfrog 速度对比junction与其他并发Hash库的对比 Turfjunction依赖于作者自己的另一个Turf库，它提供了很多跨平台（Windows、Ubuntu、OS X、iOS）的API，如线程、原子操作、锁等。 编译1234567git clone https://github.com/preshing/junction-sample.gitgit clone https://github.com/preshing/junction.gitgit clone https://github.com/preshing/turf.gitcd junction-samplemkdir buildcd buildcmake &lt;additional options&gt; .. 简单用例如下为简单用例，注意Key不可取0或1123456789101112131415161718192021222324#include &lt;junction/ConcurrentMap_Grampa.h&gt;struct Foo &#123;&#125;;void testMap() &#123; typedef junction::ConcurrentMap_Grampa&lt;turf::u32, Foo*&gt; ConcurrentMap; ConcurrentMap myMap; myMap.assign(14, new Foo); Foo* foo = myMap.get(14); foo = myMap.exchange(14, new Foo); delete foo; foo = myMap.erase(14); delete foo;&#125;int main() &#123; junction::QSBR::Context context = junction::DefaultQSBR.createContext(); testMap(); junction::DefaultQSBR.update(context); junction::DefaultQSBR.destroyContext(context); return 0;&#125; 对比测试对于Leapfrog，利用OpenMP实现4线程并发存取1000000个int，结果如下：1234Leapfrog write:2.17578Leapfrog read:1.42871Leapfrog write with omp:1.17578Leapfrog read with omp:0.547852 测试代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;junction/ConcurrentMap_Leapfrog.h&gt;#include"omp.h"typedef junction::ConcurrentMap_Leapfrog&lt;turf::u32, int*&gt; LeapfrogMap;void testMap() &#123; LeapfrogMap lfmap; float startTime = omp_get_wtime(); for(int i=2;i&lt;2+10000000;i++) &#123; int* value = new int(i); lfmap.assign(i, value); &#125; float endTime = omp_get_wtime(); std::cout &lt;&lt; "Leapfrog write:" &lt;&lt; endTime - startTime &lt;&lt; std::endl; startTime = omp_get_wtime(); for(int i=2;i&lt;2+10000000;i++) &#123; int* value = lfmap.get(i); *value = i*i; value = lfmap.erase(i); delete value; &#125; endTime = omp_get_wtime(); std::cout &lt;&lt; "Leapfrog read:" &lt;&lt; endTime - startTime &lt;&lt; std::endl;&#125;void testMap2() &#123; LeapfrogMap lfmap; float startTime = omp_get_wtime(); #pragma omp parallel for num_threads(4) for(int i=2;i&lt;2+10000000;i++) &#123; int* value = new int(i); lfmap.assign(i, value); &#125; float endTime = omp_get_wtime(); std::cout &lt;&lt; "Leapfrog write with omp:" &lt;&lt; endTime - startTime &lt;&lt; std::endl; startTime = omp_get_wtime(); #pragma omp parallel for num_threads(4) for(int i=2;i&lt;2+10000000;i++) &#123; int* value = lfmap.get(i); *value = i*i; value = lfmap.erase(i); delete value; &#125; endTime = omp_get_wtime(); std::cout &lt;&lt; "Leapfrog read with omp:" &lt;&lt; endTime - startTime &lt;&lt; std::endl;&#125;int main() &#123; junction::QSBR::Context context = junction::DefaultQSBR.createContext(); testMap(); testMap2(); junction::DefaultQSBR.update(context); junction::DefaultQSBR.destroyContext(context); return 0;&#125; 参考文献 https://github.com/preshing/junction http://preshing.com/20160201/new-concurrent-hash-maps-for-cpp]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Hash</tag>
        <tag>并行/并发/多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于球面均匀采样的旋转变换采样]]></title>
    <url>%2F2018%2Frotation-sampling%2F</url>
    <content type="text"><![CDATA[写在前面在解决点云可见性问题时，需在同一视角（z轴正方向）下将点云绕其中心进行N次旋转变换，同时保证随机性（均匀性），所以需求一种生成N个随机旋转变换的采样方法。可以将求旋转变换的问题转化为对一个$r=1$的单位球面进行均匀采样的问题，因为球面上任意一点可看做是空间向量$\vec{v}(x,y,z)$，再用轴（叉乘产生的法向轴）角法计算与向量$\vec{z}(0,0,1)$间旋转变换，从而得到一些列的变换。但是！这样的操作选择性忽略了绕z轴的旋转，不过因为在z轴正方向视角下观察点云，绕z轴旋转并不影响可见性所以可以接受，因此这种方法其实并不是”全空间“的均匀采样。 球面均匀采样球坐标系采样为了对单位球面进行均匀采样，第一个想到的就是对球坐标系$(r,\theta,\phi)$中的$\theta$、$\phi$分别进行均匀采样，尝试绘制点云图如下所示，可见两级相较中间密度更大，整体并不均匀python代码如下：12345678910111213141516171819202122232425from numpy import *import mathimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3D x = []y = []z = []N = 50d = 2*math.pi/Nfor i in range(N): for j in range(N): zt = math.sin(d*j) zt_c = math.cos(d*j) xt = zt_*math.cos(d*i) yt = zt_*math.sin(d*i) z.append(zt) x.append(xt) y.append(yt)fig=plt.figure(dpi=120) ax=fig.add_subplot(111,projection='3d') ax.scatter(x,y,z,c='b',marker='.',s=10,linewidth=0,alpha=1,cmap='spectral') plt.show() 基于斐波那契格点的球面均匀采样根据参考文献2中所述的方法，尝试利用斐波那契格点进行球面均匀采样，通式如下，其中$n$为总N个点中第n个点，$\phi$为转角系数，$\phi$的取值并非任意，其决定了曲面上螺旋的“混乱”程度，对此参考文献3作出了详细的论证，较好的取值有$(\sqrt{5}-1)/2 \approx 0.618$、$\sqrt{2}-1 \approx 0.414$ \begin{cases} z_n &= (2n-1)/N-1 \\ x_n &= \sqrt{1-z_n^2} \cdot \cos(2 \pi n \phi)\\ y_n &= \sqrt{1-z_n^2} \cdot \sin(2 \pi n \phi)\\ \end{cases}结果如下图所示python代码如下：1234567891011121314151617181920212223import mathimport matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D x = []y = []z = []N = 2500pi = math.piphi = 0.618for n in range(1,N+1): zt = (2*n-1.0)/float(N)-1 xt = math.sqrt(1-zt*zt)*math.cos(2*pi*n*phi) yt = math.sqrt(1-zt*zt)*math.sin(2*pi*n*phi) z.append(zt) x.append(xt) y.append(yt)fig=plt.figure(dpi=120) ax=fig.add_subplot(111,projection='3d') ax.scatter(x,y,z,c='b',marker='.',s=10,linewidth=0,alpha=1,cmap='spectral') plt.show() 代码实现在通过上述方法得到单位球面均匀采样点后，通过计算$\vec{z}(0,0,1)$与$\vec{v}(x,y,z)$之间的旋转变换来得到一系列旋转变换，代码如下： sphere_uniform_sampling.h1234567891011121314151617181920212223#ifndef SPHERE_UNIFORM_SAMPLING_H#define SPHERE_UNIFORM_SAMPLING_H#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Geometry&gt;class RotationSampling&#123;public: RotationSampling(int num_, double phi_=0.414);//phi=0.414, 0.618 std::vector&lt;Eigen::Matrix3d&gt; getR(); std::vector&lt;Eigen::Matrix4d&gt; getRT();private: int num; double phi; std::vector&lt;Eigen::Vector3d&gt; genPoints(); Eigen::Matrix3d vectorRotation2R(Eigen::Vector3d v_from, Eigen::Vector3d v_to);&#125;;#endif // SPHERE_UNIFORM_SAMPLING_H sphere_uniform_sampling.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include "sphere_uniform_sampling.h"RotationSampling::RotationSampling(int num_, double phi_)&#123; num = num_; phi = phi_;&#125;std::vector&lt;Eigen::Matrix3d&gt; RotationSampling::getR()&#123; std::vector&lt;Eigen::Matrix3d&gt; r; std::vector&lt;Eigen::Vector3d&gt; points = genPoints(); Eigen::Vector3d v_from(0.0, 0.0, 1.0); for(int i=0; i&lt;points.size(); ++i) &#123; r.push_back(vectorRotation2R(v_from, points[i])); &#125; return r;&#125;std::vector&lt;Eigen::Matrix4d&gt; RotationSampling::getRT()&#123; std::vector&lt;Eigen::Matrix3d&gt; r = getR(); std::vector&lt;Eigen::Matrix4d&gt; rt; for(int i=0; i&lt;r.size(); ++i) &#123; Eigen::Matrix4d rt_ = Eigen::MatrixXd::Identity(4,4); rt_.block&lt;3, 3&gt;(0, 0) = r[i]; rt.push_back(rt_); &#125; return rt;&#125;std::vector&lt;Eigen::Vector3d&gt; RotationSampling::genPoints()&#123; std::vector&lt;Eigen::Vector3d&gt; points; for(int n=1; n&lt;=num; ++n) &#123; double z = (2.0*n-1.0)/double(num)-1.0; double x = sqrt(1.0-z*z)*cos(2.0*M_PI*n*phi); double y = sqrt(1.0-z*z)*sin(2.0*M_PI*n*phi); Eigen::Vector3d p(x,y,z); points.push_back(p); &#125; return points;&#125;Eigen::Matrix3d RotationSampling::vectorRotation2R(Eigen::Vector3d v_from, Eigen::Vector3d v_to)&#123; Eigen::Matrix3d r = Eigen::MatrixXd::Identity(3,3); v_from.normalize(); v_to.normalize(); //v_from到v_to的旋转轴 Eigen::Vector3d from_to_axis = v_from.cross(v_to); from_to_axis.normalize(); //v_from到v_to的旋转矩阵 double theta = acos(v_from.dot(v_to)); Eigen::AngleAxisd v(theta, from_to_axis); r = v.matrix(); return r;&#125; 用法123RotationSampling gen(100);std::vector&lt;Eigen::Matrix3d&gt; rt = gen.getR();std::vector&lt;Eigen::Matrix4d&gt; rt = gen.getRT(); 思考 将球面采样推广至高维 利用四元数进行旋转变换的均匀采样 分别对（1,0,0）、(0,1,0)、（0,0,1）进行旋转参考文献 https://zhuanlan.zhihu.com/p/26052376 https://zhuanlan.zhihu.com/p/25988652?group_id=828963677192491008 https://zhuanlan.zhihu.com/p/25998937?group_id=829506039526354944]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>Eigen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake中遇到的问题汇总(持续更新)]]></title>
    <url>%2F2018%2Fcmake-tips%2F</url>
    <content type="text"><![CDATA[编译动态库B时提示被链接的A库需用“-fPIC”重新编译错误：can not be used when making a shared object; recompile with -fPIC解决：重新编译A库12add_library( A $&#123;SRC&#125;)set_property(TARGET A PROPERTY POSITION_INDEPENDENT_CODE ON)]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>Cmake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bullet、osgWorks、osgBullet编译及配置（适用于最新的OSG-3.5.7，Bullet-2.87）]]></title>
    <url>%2F2017%2Fosg-compiling-osgworks-and-osgbullet%2F</url>
    <content type="text"><![CDATA[写在最前面Bullet：物理引擎osgWorks：一些osg工具osgBullet：基于Bullet的osg物理引擎本文介绍了Bullet、osgWorks及osgBullet编译过程中的一些坑，这两个库最后一次更新都在数年之前，因为年久失修与现有版本的Bullet间有诸多问题 系统环境ubuntu: 16.04CMake: 3.5.1OSG: 3.5.7Bullet: 2.87osgWorks: 3.0osgBullet: 3.0 Bullet编译源代码：Github链接下载最新的Release版本12345mkdir buildcd buildcmake ..makemake install 2&gt;&amp;1 | tee install.log 编译完成之后可以尝试一下Example\ExampleBrowser这样基本就搞定了，其他编译方式premake什么的没尝试成功 osgWorks编译及配置源代码下载、编译源代码：Github链接12345mkdir buildcd buildcmake ..makemake install 2&gt;&amp;1 | tee install.log 过程中出现的问题及解决办法：1.报错：mgv.mergeGeode(geode)在/src/osgwTools/GeometryModifier.cpp中添加头文件#include &lt;osg/Group&gt;将mgv.mergeGeode(geode);修改为mgv.mergeGroup(*geode.asGroup()); 2.报错：void set(value_type a00, value_type a01, value_type a02,value_type a03,在/src/osgwTools/Orientation中将123456789101112osg::Vec3d Orientation::getYPR( const osg::Quat&amp; q ) const&#123; osg::Matrix m; m.set( q ); return( getYPR( m ) );&#125;void Orientation::getYPR( const osg::Quat&amp; q, double&amp; yaw, double&amp; pitch, double&amp; roll ) const&#123; osg::Matrix m; m.set( q ); getYPR( m, yaw, pitch, roll );&#125; 修改为12345678910osg::Vec3d Orientation::getYPR( const osg::Quat&amp; q ) const&#123; osg::Matrix m(q); return( getYPR( m ) );&#125;void Orientation::getYPR( const osg::Quat&amp; q, double&amp; yaw, double&amp; pitch, double&amp; roll ) const&#123; osg::Matrix m(q); getYPR( m, yaw, pitch, roll );&#125; 环境变量配置1sudo gedit /etc/profile 在最末尾加上如下语句12#osgWorksexport osgWorks_DIR=/usr/local/lib 执行source /etc/profile或重启以更新系统环境变量 osgBullet编译及配置源代码下载、编译源代码：Github链接12345mkdir buildcd buildcmake ..makemake install 2&gt;&amp;1 | tee install.log 过程中出现的问题及解决办法：1.报错：找不到osgWorks，CMake Error at CMakeModules/FindosgWorks.cmake:39 (MESSAGE)指定osgWorks_DIR为usr/local/lib 2.报错：无法生成动态链接库1/usr/bin/ld: /usr/local/lib/libBulletCollision.a(btBoxShape.o): relocation R_X86_64_32S against _ZNK21btConvexInternalShape9getMarginEv can not be used when making a shared object; recompile with -fPIC 将BUILD_SHARED_LIBS取消勾选 3.报错：编译example/patch-lowlevel时报“未定义的引用”错误将/examples/CMakeLists.txt中的ADD_SUBDIRECTORY( patch-lowlevel )注释掉 4.报错：no matching function for call to ‘osg::TriangleFunctor::operator()(const Vec3&amp;, const Vec3&amp;, const Vec3&amp;)’将/usr/local/include/osg/TriangleFunctor中以this-&gt;operator()开头的语句末尾增加一个参数false例如：1this-&gt;operator()(*(vptr),*(vptr+1),*(vptr+2)); 改为：1this-&gt;operator()(*(vptr),*(vptr+1),*(vptr+2),false); 环境变量配置1sudo gedit /etc/profile 在最末尾加上如下语句12#osgBulletexport osgBullet_DIR=/usr/local/lib 执行source /etc/profile或重启以更新系统环境变量 以上osgWorks及osgBullet编译安装完毕 参考https://www.cnblogs.com/lyggqm/p/6733423.html]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>OSG</tag>
        <tag>Bullet</tag>
        <tag>osgWorks</tag>
        <tag>osgBullet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSG、osgQT编译及配置]]></title>
    <url>%2F2017%2Fosg-compiling-and-configuration%2F</url>
    <content type="text"><![CDATA[写在最前面本文介绍了OSG及osgQT的编译及配置过程 系统环境ubuntu: 16.04CMake: 3.5.1OSG: 3.5.7 OSG编译及配置源代码下载、编译源代码：Github链接12345mkdir buildcd buildcmake -D BUILD_OSG_EXAMPLES=ON ..makemake install 数据文件配置数据文件下载：Github链接解压存放，例如/home/&lt;用户名&gt;/Documents/OpenSceneGraph-Data OSG环境变量配置1sudo gedit /etc/profile 在最末尾加上如下语句12345#OSGexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib64export PATH=$PATH:/usr/local/share/OpenSceneGraph/binexport OSG_FILE_PATH=/home/&lt;用户名&gt;/Documents/OpenSceneGraph-Dataexport OSG_DIR=/usr/local/lib64 分别为 添加OSG库路径到系统共享库路径 OSG的一些可执行文件路径 OSG的数据文件路径（根据实际存放位置修改） OSG动态链接库路径 执行source /etc/profile或重启以更新系统环境变量 至此OSG配置完成 测试运行如下命令1osgviewer cow.osgt 如显示以下图像则为测试成功 osgQT编译源代码下载、编译源代码：Github链接12345mkdir buildcd buildcmake -D BUILD_OSG_EXAMPLES=ON ..makemake install 测试通过运行编译出来的例子验证是否配置成功 QT中使用OSG的CMakeLists.txt写法并非完整写法，可供参考12345678## 增加OSG的依赖FIND_PACKAGE(OpenSceneGraph REQUIRED COMPONENTS osgDB osgGA osgUtil osgText osgViewer osgWidget)LIST(APPEND INCS_DIR $&#123;OPENSCENEGRAPH_INCLUDE_DIRS&#125;)FILE(GLOB OST_QT_LIB "/usr/local/lib64/libosgQt5.so")LIST(APPEND LIBS $&#123;OPENSCENEGRAPH_LIBRARIES&#125; $&#123;OST_QT_LIB&#125;)INCLUDE_DIRECTORIES($&#123;INCS_DIR&#125;)TARGET_LINK_LIBRARIES(Project $&#123;LIBS&#125;) 注：CMake中的FIND_PACKAGE(osgQT)测试无效，不清楚是不是版本问题]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>OSG</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用七牛qshell工具上传Hexo博客图片]]></title>
    <url>%2F2017%2Fhexo-qiniu-image-upload%2F</url>
    <content type="text"><![CDATA[写在最前面本文对利用七牛qshell上传博客图片的设置及使用方法进行了整理 系统环境ubuntu: 16.04hexo: 3.3.8 qshell的配置下载qshellGithub链接下载对应的版本，本文以ubuntu为例 qhell的配置将qshell可执行文件存放到home文件夹下例如/home/用户名/qiniu添加可执行权限chmod +x qshell将qshell所在目录加入系统环境变量1$ sudo gedit ~/.bashrc 添加如下环境变量1export PATH=$PATH:/home/用户名/qiniu 运行source ~/.bashrc使修改立即生效在终端内输入qshell测试一下是否添加成功 配置账户进入/home/用户名/qiniu目录，建立账户，此处使用-m多账户模式将账户信息建立在qshell工具所在目录，其中AccessKey和SecretKey可从七牛账户中获取1$ qshell -m account &lt;AccessKey&gt; &lt;SecretKey&gt; 账户建立完毕用如下命令查看是否建立成功1$ qshell -m account 配置上传设置在/home/用户名/qiniu目录下建立config文件输入如下参数，前四项自行填写123456789101112131415161718&#123; &quot;src_dir&quot; : &quot;/home/用户名/.../source/_posts&quot;, &quot;access_key&quot; : &quot;ak&quot;, &quot;secret_key&quot; : &quot;sk&quot;, &quot;bucket&quot; : &quot;bucket名称&quot;, &quot;ignore_dir&quot; : false, &quot;overwrite&quot; : true, &quot;check_exists&quot; : true, &quot;check_hash&quot; : false, &quot;check_size&quot; : false, &quot;skip_file_prefixes&quot; : &quot;.git&quot;, &quot;skip_path_prefixes&quot; : &quot;&quot;, &quot;skip_fixed_strings&quot; : &quot;&quot;, &quot;skip_suffixes&quot; : &quot;.md&quot;, &quot;rescan_local&quot; : true, &quot;log_file&quot; : &quot;upload.log&quot;, &quot;log_level&quot; : &quot;info&quot;&#125; 文件上传当_posts下添加的图片之后，在/home/用户名/qiniu目录下运行一下命令即可完成上传1$ qshell -m qupload config 外链获取方法1直接在网页界面复制外链 方法2使用qshell获取域名及文件列表，并将两者进行拼接，/home/用户名/qiniu目录下获取域名1$ qshell -m domains &lt;空间名&gt; 获取文件列表1$ qshell -m listbucket &lt;空间名&gt; &lt;存储文件列表的文件名&gt; 将两者进行拼接即可获取完整外链存储至final文件1$ cat &lt;存储文件列表的文件名&gt; | awk '&#123;print "域名/"$1&#125;' &gt;final 参考https://github.com/qiniu/qshellhttps://segmentfault.com/q/1010000005149132/a-1020000005150007]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
