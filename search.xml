<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++并发Hash库junction简介]]></title>
    <url>%2F2018%2Fconcurrent-hash-guide%2F</url>
    <content type="text"><![CDATA[写在最前面由于一个算法环节的优化中，需要通过Hash表的并发读写来优化速度，而std::map和std::unordered_map并非线程安全，如果一定要用只能加锁，但这样又会有额外消耗，得不偿失。因此需求一个线程安全的并发HashMap，现有的C++库选择并不多比如TBB，偶然间发现了Junction_ConcurrentMap库,本文对HashMap、现有C++并发Hash库、Junction的编译及用例做了简要介绍，并未涉及Hash函数相关内容。 什么是HashMap数组和链表数组和链表是两种常见的数据结构，他们各有优缺点： 数组长度固定，下标与值一一对应，可以通过下标对存储的值进行索引,查询时间复杂度为O(1)。其长度固定正是其缺点，分配长度过短如果实际存储数据量超过定长会报错，而分配过大空间又会造成不必要的浪费，且占据的空间不会随元素的删除而释放。 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，其优势为无长度限制，非顺序的存储结构使内存利用更为充分，一般的单链表查询时间复杂度为O(n)。 HashMapHashMap则是一种既不定长又无需遍历查询的数据结构，在无冲突的情况下时间复杂度为O(1)，而这是通过牺牲更大空间而实现的，是一种空间换时间的做法。HashMap用KEY-VALUE来实现数据存储，插入数据时将KEY通过Hash函数转换为Hashcode(通常为32位或64位uint)，由Hashcode决定存储的位置。但是存在一个冲突问题，那就是当你用Hash函数作用在两个互不相同KEY时，得到了相同的Hashcode，也就是不同的KEY-VALUE将会存到相同位置，这时就需要解决冲突，通常的解决办法有：开放定址法、链地址法、再哈希法等。 C++并发HashMapC++并没有像Java那样原生的ConcurrentHashMap，通常有如下解决方案： std::map+std::mutex：利用std::map加锁实现 TBB concurrent_hash_map：Intel公司开发的并行编程开发的工具 libCds MichaelKVList：一个无锁、细粒度算法的C++模板库 nbds hashtable_t：非阻塞结构的C实现 Tervel HashMap：一种为共享内存系统设计的无等待算法 Folly AtomicHashMap：一个Facebook开源的C++库 junction关于junctionjunction是一个并发数据结构库，也正是本文将着重介绍的。junction包含多种HashMap的实现方式： ConcurrentMap_Crude：一种并发HashMap的简陋实现 junction::ConcurrentMap_Linea：一种受Java non-blocking HashMap启发的简单无锁HashMap junction::ConcurrentMap_Leapfrog：类似于Linea，但是使用了跳房子哈希法（Hopscotch Hashing）的松散搜索策略 junction::ConcurrentMap_Grampa：其与Leapfrog类似，但是在数据量大的时候会拆分成多个更小的、定长的Leapfrog 速度对比junction与其他并发Hash库的对比 Turfjunction依赖于作者自己的另一个Turf库，它提供了很多跨平台（Windows、Ubuntu、OS X、iOS）的API，如线程、原子操作、锁等。 编译1234567git clone https://github.com/preshing/junction-sample.gitgit clone https://github.com/preshing/junction.gitgit clone https://github.com/preshing/turf.gitcd junction-samplemkdir buildcd buildcmake &lt;additional options&gt; .. 简单用例如下为简单用例，注意Key不可取0或1123456789101112131415161718192021222324#include &lt;junction/ConcurrentMap_Grampa.h&gt;struct Foo &#123;&#125;;void testMap() &#123; typedef junction::ConcurrentMap_Grampa&lt;turf::u32, Foo*&gt; ConcurrentMap; ConcurrentMap myMap; myMap.assign(14, new Foo); Foo* foo = myMap.get(14); foo = myMap.exchange(14, new Foo); delete foo; foo = myMap.erase(14); delete foo;&#125;int main() &#123; junction::QSBR::Context context = junction::DefaultQSBR.createContext(); testMap(); junction::DefaultQSBR.update(context); junction::DefaultQSBR.destroyContext(context); return 0;&#125; 对比测试对于Leapfrog，利用OpenMP实现4线程并发存取1000000个int，结果如下：1234Leapfrog write:2.17578Leapfrog read:1.42871Leapfrog write with omp:1.17578Leapfrog read with omp:0.547852 测试代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;junction/ConcurrentMap_Leapfrog.h&gt;#include"omp.h"typedef junction::ConcurrentMap_Leapfrog&lt;turf::u32, int*&gt; LeapfrogMap;void testMap() &#123; LeapfrogMap lfmap; float startTime = omp_get_wtime(); for(int i=2;i&lt;2+10000000;i++) &#123; int* value = new int(i); lfmap.assign(i, value); &#125; float endTime = omp_get_wtime(); std::cout &lt;&lt; "Leapfrog write:" &lt;&lt; endTime - startTime &lt;&lt; std::endl; startTime = omp_get_wtime(); for(int i=2;i&lt;2+10000000;i++) &#123; int* value = lfmap.get(i); *value = i*i; value = lfmap.erase(i); delete value; &#125; endTime = omp_get_wtime(); std::cout &lt;&lt; "Leapfrog read:" &lt;&lt; endTime - startTime &lt;&lt; std::endl;&#125;void testMap2() &#123; LeapfrogMap lfmap; float startTime = omp_get_wtime(); #pragma omp parallel for num_threads(4) for(int i=2;i&lt;2+10000000;i++) &#123; int* value = new int(i); lfmap.assign(i, value); &#125; float endTime = omp_get_wtime(); std::cout &lt;&lt; "Leapfrog write with omp:" &lt;&lt; endTime - startTime &lt;&lt; std::endl; startTime = omp_get_wtime(); #pragma omp parallel for num_threads(4) for(int i=2;i&lt;2+10000000;i++) &#123; int* value = lfmap.get(i); *value = i*i; value = lfmap.erase(i); delete value; &#125; endTime = omp_get_wtime(); std::cout &lt;&lt; "Leapfrog read with omp:" &lt;&lt; endTime - startTime &lt;&lt; std::endl;&#125;int main() &#123; junction::QSBR::Context context = junction::DefaultQSBR.createContext(); testMap(); testMap2(); junction::DefaultQSBR.update(context); junction::DefaultQSBR.destroyContext(context); return 0;&#125; 参考文献 https://github.com/preshing/junction http://preshing.com/20160201/new-concurrent-hash-maps-for-cpp]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Hash</tag>
        <tag>并行/并发/多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于球面均匀采样的旋转变换采样]]></title>
    <url>%2F2018%2Frotation-sampling%2F</url>
    <content type="text"><![CDATA[写在前面在解决点云可见性问题时，需在同一视角（z轴正方向）下将点云绕其中心进行N次旋转变换，同时保证随机性（均匀性），所以需求一种生成N个随机旋转变换的采样方法。可以将求旋转变换的问题转化为对一个$r=1$的单位球面进行均匀采样的问题，因为球面上任意一点可看做是空间向量$\vec{v}(x,y,z)$，再用轴（叉乘产生的法向轴）角法计算与向量$\vec{z}(0,0,1)$间旋转变换，从而得到一些列的变换。但是！这样的操作选择性忽略了绕z轴的旋转，不过因为在z轴正方向视角下观察点云，绕z轴旋转并不影响可见性所以可以接受，因此这种方法其实并不是”全空间“的均匀采样。 球面均匀采样球坐标系采样为了对单位球面进行均匀采样，第一个想到的就是对球坐标系$(r,\theta,\phi)$中的$\theta$、$\phi$分别进行均匀采样，尝试绘制点云图如下所示，可见两级相较中间密度更大，整体并不均匀python代码如下：12345678910111213141516171819202122232425from numpy import *import mathimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3D x = []y = []z = []N = 50d = 2*math.pi/Nfor i in range(N): for j in range(N): zt = math.sin(d*j) zt_c = math.cos(d*j) xt = zt_*math.cos(d*i) yt = zt_*math.sin(d*i) z.append(zt) x.append(xt) y.append(yt)fig=plt.figure(dpi=120) ax=fig.add_subplot(111,projection='3d') ax.scatter(x,y,z,c='b',marker='.',s=10,linewidth=0,alpha=1,cmap='spectral') plt.show() 基于斐波那契格点的球面均匀采样根据参考文献2中所述的方法，尝试利用斐波那契格点进行球面均匀采样，通式如下，其中$n$为总N个点中第n个点，$\phi$为转角系数，$\phi$的取值并非任意，其决定了曲面上螺旋的“混乱”程度，对此参考文献3作出了详细的论证，较好的取值有$(\sqrt{5}-1)/2 \approx 0.618$、$\sqrt{2}-1 \approx 0.414$ \begin{cases} z_n &= (2n-1)/N-1 \\ x_n &= \sqrt{1-z_n^2} \cdot \cos(2 \pi n \phi)\\ y_n &= \sqrt{1-z_n^2} \cdot \sin(2 \pi n \phi)\\ \end{cases}结果如下图所示python代码如下：1234567891011121314151617181920212223import mathimport matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D x = []y = []z = []N = 2500pi = math.piphi = 0.618for n in range(1,N+1): zt = (2*n-1.0)/float(N)-1 xt = math.sqrt(1-zt*zt)*math.cos(2*pi*n*phi) yt = math.sqrt(1-zt*zt)*math.sin(2*pi*n*phi) z.append(zt) x.append(xt) y.append(yt)fig=plt.figure(dpi=120) ax=fig.add_subplot(111,projection='3d') ax.scatter(x,y,z,c='b',marker='.',s=10,linewidth=0,alpha=1,cmap='spectral') plt.show() 代码实现在通过上述方法得到单位球面均匀采样点后，通过计算$\vec{z}(0,0,1)$与$\vec{v}(x,y,z)$之间的旋转变换来得到一系列旋转变换，代码如下： sphere_uniform_sampling.h1234567891011121314151617181920212223#ifndef SPHERE_UNIFORM_SAMPLING_H#define SPHERE_UNIFORM_SAMPLING_H#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Geometry&gt;class RotationSampling&#123;public: RotationSampling(int num_, double phi_=0.414);//phi=0.414, 0.618 std::vector&lt;Eigen::Matrix3d&gt; getR(); std::vector&lt;Eigen::Matrix4d&gt; getRT();private: int num; double phi; std::vector&lt;Eigen::Vector3d&gt; genPoints(); Eigen::Matrix3d vectorRotation2R(Eigen::Vector3d v_from, Eigen::Vector3d v_to);&#125;;#endif // SPHERE_UNIFORM_SAMPLING_H sphere_uniform_sampling.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include "sphere_uniform_sampling.h"RotationSampling::RotationSampling(int num_, double phi_)&#123; num = num_; phi = phi_;&#125;std::vector&lt;Eigen::Matrix3d&gt; RotationSampling::getR()&#123; std::vector&lt;Eigen::Matrix3d&gt; r; std::vector&lt;Eigen::Vector3d&gt; points = genPoints(); Eigen::Vector3d v_from(0.0, 0.0, 1.0); for(int i=0; i&lt;points.size(); ++i) &#123; r.push_back(vectorRotation2R(v_from, points[i])); &#125; return r;&#125;std::vector&lt;Eigen::Matrix4d&gt; RotationSampling::getRT()&#123; std::vector&lt;Eigen::Matrix3d&gt; r = getR(); std::vector&lt;Eigen::Matrix4d&gt; rt; for(int i=0; i&lt;r.size(); ++i) &#123; Eigen::Matrix4d rt_ = Eigen::MatrixXd::Identity(4,4); rt_.block&lt;3, 3&gt;(0, 0) = r[i]; rt.push_back(rt_); &#125; return rt;&#125;std::vector&lt;Eigen::Vector3d&gt; RotationSampling::genPoints()&#123; std::vector&lt;Eigen::Vector3d&gt; points; for(int n=1; n&lt;=num; ++n) &#123; double z = (2.0*n-1.0)/double(num)-1.0; double x = sqrt(1.0-z*z)*cos(2.0*M_PI*n*phi); double y = sqrt(1.0-z*z)*sin(2.0*M_PI*n*phi); Eigen::Vector3d p(x,y,z); points.push_back(p); &#125; return points;&#125;Eigen::Matrix3d RotationSampling::vectorRotation2R(Eigen::Vector3d v_from, Eigen::Vector3d v_to)&#123; Eigen::Matrix3d r = Eigen::MatrixXd::Identity(3,3); v_from.normalize(); v_to.normalize(); //v_from到v_to的旋转轴 Eigen::Vector3d from_to_axis = v_from.cross(v_to); from_to_axis.normalize(); //v_from到v_to的旋转矩阵 double theta = acos(v_from.dot(v_to)); Eigen::AngleAxisd v(theta, from_to_axis); r = v.matrix(); return r;&#125; 用法123RotationSampling gen(100);std::vector&lt;Eigen::Matrix3d&gt; rt = gen.getR();std::vector&lt;Eigen::Matrix4d&gt; rt = gen.getRT(); 思考 将球面采样推广至高维 利用四元数进行旋转变换的均匀采样 分别对（1,0,0）、(0,1,0)、（0,0,1）进行旋转参考文献 https://zhuanlan.zhihu.com/p/26052376 https://zhuanlan.zhihu.com/p/25988652?group_id=828963677192491008 https://zhuanlan.zhihu.com/p/25998937?group_id=829506039526354944]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Eigen</tag>
        <tag>点云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake中遇到的问题汇总(持续更新)]]></title>
    <url>%2F2018%2Fcmake-tips%2F</url>
    <content type="text"><![CDATA[编译动态库B时提示被链接的A库需用“-fPIC”重新编译错误：can not be used when making a shared object; recompile with -fPIC解决：重新编译A库12add_library( A $&#123;SRC&#125;)set_property(TARGET A PROPERTY POSITION_INDEPENDENT_CODE ON)]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>Cmake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bullet、osgWorks、osgBullet编译及配置（适用于最新的OSG-3.5.7，Bullet-2.87）]]></title>
    <url>%2F2017%2Fosg-compiling-osgworks-and-osgbullet%2F</url>
    <content type="text"><![CDATA[写在最前面Bullet：物理引擎osgWorks：一些osg工具osgBullet：基于Bullet的osg物理引擎本文介绍了Bullet、osgWorks及osgBullet编译过程中的一些坑，这两个库最后一次更新都在数年之前，因为年久失修与现有版本的Bullet间有诸多问题 系统环境ubuntu: 16.04CMake: 3.5.1OSG: 3.5.7Bullet: 2.87osgWorks: 3.0osgBullet: 3.0 Bullet编译源代码：Github链接下载最新的Release版本12345mkdir buildcd buildcmake ..makemake install 2&gt;&amp;1 | tee install.log 编译完成之后可以尝试一下Example\ExampleBrowser这样基本就搞定了，其他编译方式premake什么的没尝试成功 osgWorks编译及配置源代码下载、编译源代码：Github链接12345mkdir buildcd buildcmake ..makemake install 2&gt;&amp;1 | tee install.log 过程中出现的问题及解决办法：1.报错：mgv.mergeGeode(geode)在/src/osgwTools/GeometryModifier.cpp中添加头文件#include &lt;osg/Group&gt;将mgv.mergeGeode(geode);修改为mgv.mergeGroup(*geode.asGroup()); 2.报错：void set(value_type a00, value_type a01, value_type a02,value_type a03,在/src/osgwTools/Orientation中将123456789101112osg::Vec3d Orientation::getYPR( const osg::Quat&amp; q ) const&#123; osg::Matrix m; m.set( q ); return( getYPR( m ) );&#125;void Orientation::getYPR( const osg::Quat&amp; q, double&amp; yaw, double&amp; pitch, double&amp; roll ) const&#123; osg::Matrix m; m.set( q ); getYPR( m, yaw, pitch, roll );&#125; 修改为12345678910osg::Vec3d Orientation::getYPR( const osg::Quat&amp; q ) const&#123; osg::Matrix m(q); return( getYPR( m ) );&#125;void Orientation::getYPR( const osg::Quat&amp; q, double&amp; yaw, double&amp; pitch, double&amp; roll ) const&#123; osg::Matrix m(q); getYPR( m, yaw, pitch, roll );&#125; 环境变量配置1sudo gedit /etc/profile 在最末尾加上如下语句12#osgWorksexport osgWorks_DIR=/usr/local/lib 执行source /etc/profile或重启以更新系统环境变量 osgBullet编译及配置源代码下载、编译源代码：Github链接12345mkdir buildcd buildcmake ..makemake install 2&gt;&amp;1 | tee install.log 过程中出现的问题及解决办法：1.报错：找不到osgWorks，CMake Error at CMakeModules/FindosgWorks.cmake:39 (MESSAGE)指定osgWorks_DIR为usr/local/lib 2.报错：无法生成动态链接库1/usr/bin/ld: /usr/local/lib/libBulletCollision.a(btBoxShape.o): relocation R_X86_64_32S against _ZNK21btConvexInternalShape9getMarginEv can not be used when making a shared object; recompile with -fPIC 将BUILD_SHARED_LIBS取消勾选 3.报错：编译example/patch-lowlevel时报“未定义的引用”错误将/examples/CMakeLists.txt中的ADD_SUBDIRECTORY( patch-lowlevel )注释掉 4.报错：no matching function for call to ‘osg::TriangleFunctor::operator()(const Vec3&amp;, const Vec3&amp;, const Vec3&amp;)’将/usr/local/include/osg/TriangleFunctor中以this-&gt;operator()开头的语句末尾增加一个参数false例如：1this-&gt;operator()(*(vptr),*(vptr+1),*(vptr+2)); 改为：1this-&gt;operator()(*(vptr),*(vptr+1),*(vptr+2),false); 环境变量配置1sudo gedit /etc/profile 在最末尾加上如下语句12#osgBulletexport osgBullet_DIR=/usr/local/lib 执行source /etc/profile或重启以更新系统环境变量 以上osgWorks及osgBullet编译安装完毕 参考https://www.cnblogs.com/lyggqm/p/6733423.html]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>OSG</tag>
        <tag>Bullet</tag>
        <tag>osgWorks</tag>
        <tag>osgBullet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSG、osgQT编译及配置]]></title>
    <url>%2F2017%2Fosg-compiling-and-configuration%2F</url>
    <content type="text"><![CDATA[写在最前面本文介绍了OSG及osgQT的编译及配置过程 系统环境ubuntu: 16.04CMake: 3.5.1OSG: 3.5.7 OSG编译及配置源代码下载、编译源代码：Github链接12345mkdir buildcd buildcmake -D BUILD_OSG_EXAMPLES=ON ..makemake install 数据文件配置数据文件下载：Github链接解压存放，例如/home/&lt;用户名&gt;/Documents/OpenSceneGraph-Data OSG环境变量配置1sudo gedit /etc/profile 在最末尾加上如下语句12345#OSGexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib64export PATH=$PATH:/usr/local/share/OpenSceneGraph/binexport OSG_FILE_PATH=/home/&lt;用户名&gt;/Documents/OpenSceneGraph-Dataexport OSG_DIR=/usr/local/lib64 分别为 添加OSG库路径到系统共享库路径 OSG的一些可执行文件路径 OSG的数据文件路径（根据实际存放位置修改） OSG动态链接库路径 执行source /etc/profile或重启以更新系统环境变量 至此OSG配置完成 测试运行如下命令1osgviewer cow.osgt 如显示以下图像则为测试成功 osgQT编译源代码下载、编译源代码：Github链接12345mkdir buildcd buildcmake -D BUILD_OSG_EXAMPLES=ON ..makemake install 测试通过运行编译出来的例子验证是否配置成功 QT中使用OSG的CMakeLists.txt写法并非完整写法，可供参考12345678## 增加OSG的依赖FIND_PACKAGE(OpenSceneGraph REQUIRED COMPONENTS osgDB osgGA osgUtil osgText osgViewer osgWidget)LIST(APPEND INCS_DIR $&#123;OPENSCENEGRAPH_INCLUDE_DIRS&#125;)FILE(GLOB OST_QT_LIB "/usr/local/lib64/libosgQt5.so")LIST(APPEND LIBS $&#123;OPENSCENEGRAPH_LIBRARIES&#125; $&#123;OST_QT_LIB&#125;)INCLUDE_DIRECTORIES($&#123;INCS_DIR&#125;)TARGET_LINK_LIBRARIES(Project $&#123;LIBS&#125;) 注：CMake中的FIND_PACKAGE(osgQT)测试无效，不清楚是不是版本问题]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>OSG</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用七牛qshell工具上传Hexo博客图片]]></title>
    <url>%2F2017%2Fhexo-qiniu-image-upload%2F</url>
    <content type="text"><![CDATA[写在最前面本文对利用七牛qshell上传博客图片的设置及使用方法进行了整理 系统环境ubuntu: 16.04hexo: 3.3.8 qshell的配置下载qshellGithub链接下载对应的版本，本文以ubuntu为例 qhell的配置将qshell可执行文件存放到home文件夹下例如/home/用户名/qiniu添加可执行权限chmod +x qshell将qshell所在目录加入系统环境变量1$ sudo gedit ~/.bashrc 添加如下环境变量1export PATH=$PATH:/home/用户名/qiniu 运行source ~/.bashrc使修改立即生效在终端内输入qshell测试一下是否添加成功 配置账户进入/home/用户名/qiniu目录，建立账户，此处使用-m多账户模式将账户信息建立在qshell工具所在目录，其中AccessKey和SecretKey可从七牛账户中获取1$ qshell -m account &lt;AccessKey&gt; &lt;SecretKey&gt; 账户建立完毕用如下命令查看是否建立成功1$ qshell -m account 配置上传设置在/home/用户名/qiniu目录下建立config文件输入如下参数，前四项自行填写123456789101112131415161718&#123; &quot;src_dir&quot; : &quot;/home/用户名/.../source/_posts&quot;, &quot;access_key&quot; : &quot;ak&quot;, &quot;secret_key&quot; : &quot;sk&quot;, &quot;bucket&quot; : &quot;bucket名称&quot;, &quot;ignore_dir&quot; : false, &quot;overwrite&quot; : true, &quot;check_exists&quot; : true, &quot;check_hash&quot; : false, &quot;check_size&quot; : false, &quot;skip_file_prefixes&quot; : &quot;.git&quot;, &quot;skip_path_prefixes&quot; : &quot;&quot;, &quot;skip_fixed_strings&quot; : &quot;&quot;, &quot;skip_suffixes&quot; : &quot;.md&quot;, &quot;rescan_local&quot; : true, &quot;log_file&quot; : &quot;upload.log&quot;, &quot;log_level&quot; : &quot;info&quot;&#125; 文件上传当_posts下添加的图片之后，在/home/用户名/qiniu目录下运行一下命令即可完成上传1$ qshell -m qupload config 外链获取方法1直接在网页界面复制外链 方法2使用qshell获取域名及文件列表，并将两者进行拼接，/home/用户名/qiniu目录下获取域名1$ qshell -m domains &lt;空间名&gt; 获取文件列表1$ qshell -m listbucket &lt;空间名&gt; &lt;存储文件列表的文件名&gt; 将两者进行拼接即可获取完整外链存储至final文件1$ cat &lt;存储文件列表的文件名&gt; | awk '&#123;print "域名/"$1&#125;' &gt;final 参考https://github.com/qiniu/qshellhttps://segmentfault.com/q/1010000005149132/a-1020000005150007]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
